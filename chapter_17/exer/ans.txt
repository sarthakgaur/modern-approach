1.
    void *my_malloc(int n) {
        void *p;
        p = malloc(n);

        if (p == NULL) {
            printf("Error: malloc failed in my_malloc\n");
            exit(EXIT_FAILURE);
        }

        return p;
    }

2.
    char *duplicate(char *str) {
        int len = strlen(str);
        char *p = malloc(len + 1);

        if (p == NULL)
            return NULL;

        strcpy(p, str);
        return p;
    }

3.
    int *create_array(int n, int initial_value) {
        int *p = malloc(n * sizeof(int));

        if (p == NULL)
            return NULL;

        int *p2;
        for (p2 = p; p2 < p2 + n; p2++)
            *p2 = initial_value;

        return p;
    }

4.
    p = malloc(sizeof(rectangle));

    if (p == NULL)
        return;

    p->upper_left = {10, 25};
    p->lower_right = {20, 15};

5.
    a. Not legal. Should be p->d.b = ' '.
    b. Legal.
    c. Legal.
    d. Not legal. Should be p->d.c = 20;

6.
    struct node *delete_from_list(struct node *list, int n) {
        struct node *cur;

        if (list != NULL && list->value == n) {
            cur = list->next;
            free(list);
            return cur;
        }

        for (cur = list;
             cur != NULL && cur->next != NULL && cur->next->value != n;
             cur = cur->next)
            ;

        if (cur == NULL)
            return list;
        else if (cur->next != NULL) {
            cur->next = cur->next->next;
            free(cur->next);
        }

        return list;
    }

7.
    When we free(p), we won't be able to access the next pointer. Here's the correct version:
    p = first;
    struct node *temp;
    while (p != NULL) {
        temp = p;
        p = p->next;
        free(temp);
    }

8. In file src/stack.c

9. True. (&x)->a is the same as (*(&x)).a which is same as x.a. 

10.
    void print_part(struct part *p) {
        printf("Part number: %d\n", p->number);
        printf("Part name: %d\n", p->name);
        printf("Quantity on hand: %d\n", p->on_hand);
    }

11.
    int count_occurrences(struct node *list, int n) {
        int count = 0;
        struct node *p = list;

        while (p != NULL) {
            if (p->value == n)
                count++;
            p = p->next;
        }

        return count;
    }

12.
    struct node *find_last(struct node *list, int n) {
        struct node *last = NULL;

        while (list != NULL) {
            if (list->value == n)
                last = list;
            list = list->next;
        }

        return last;
    }

13.
    struct node *insert_into_ordered_list(struct node *list, struct node *new_node) {
        struct node *cur = list, *prev = NULL;
        while (cur != NULL && cur->value <= new_node->value) {
            prev = cur;
            cur = cur->next;
        }

        if (cur == NULL)
            return new_node;
        else if (prev == NULL) {
            new_node->next = list;
            return new_node;
        }

        prev->next = new_node;
        new_node->next = cur;

        return list;
    } // Wrong. Use the pointer to pointer approach.

14.
    void delete_from_list(struct node **list, int n) {
        struct node *cur, *prev;

        for (cur = *list, prev = NULL;
             cur != NULL && cur->value != n;
             prev = cur, cur = cur->next)
            ;

        if (cur == NULL)
            return;
        if (prev == NULL)
            *list = (*list)->next;
        else
            prev->next = cur->next;
        free(cur);
    }

15. Answer: 3. The while loop in f1 runs three times so n is increment three times. f1 returns 3 which gets printed. 

16.
    int sum(int (*f) (int), int start, int end) {
        int sum = 0;

        for (int i = start; i <= end; i++)
            sum += (*f)(i);

        return sum;
    }

17.
    qsort(&a[50], 50, sizeof(int), compare_parts); // Wrong. First argument should be pointer.

18.
    int compare_parts(const void *p, const void *q) {
        const struct part *p1 = p;
        const struct part *q1 = q;

        if (p1->number < q1->number)
            return 1;
        else if (p1->number == q1->number)
            return 0;
        else
            return -1;
    }

19.
    void select_fn(char *ch) {
        int group_len = (int) (sizeof(file_cmd) / sizeof(file_cmd[0]));

        for (int i = 0; i < group_len; i++) {
            if (strcmp(ch, file_cmd[i].cmd_name) == 0) {
                (*file_cmd[i].cmd_pointer)(); // forgot the member
                break;
            }
    }
